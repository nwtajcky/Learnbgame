# Copyright 2019 CrowdMaster Development Team
#
# ##### BEGIN GPL LICENSE BLOCK ######
# This file is part of CrowdMaster.
#
# CrowdMaster is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CrowdMaster is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CrowdMaster.  If not, see <http://www.gnu.org/licenses/>.
# ##### END GPL LICENSE BLOCK #####

import logging
import math
import os
import random
import time
from collections import OrderedDict
from math import radians

import bmesh
import bpy
import mathutils
from mathutils import Euler

from .. import SCENE_OT_cm_agent_add, cm_timings
from ..cm_channels import Path
from ..libs.ins_octree import createOctreeFromBPYObjs
from ..libs.ins_vector import Vector

logger = logging.getLogger("CrowdMaster")

BVHTree = mathutils.bvhtree.BVHTree
KDTree = mathutils.kdtree.KDTree

tmpPathChannel = Path(None)

# ==================== Some base classes ====================


class Template():
    """Abstract super class.
    Templates are a description of how to create some arrangement of agents"""

    def __init__(self, inputs, settings, bpyName):
        """":param input: A list of Templates or GeoTemplates generated by the
        nodes that are connected to inputs of this node"""
        self.inputs = inputs
        self.bpyName = bpyName
        self.settings = settings

        self.buildCount = 0
        self.checkCache = None

    def build(self, buildRequest):
        """Called when this template is being used to modify the scene"""
        self.buildCount += 1

    def check(self):
        """Return true if the inputs and settings are correct"""
        return True


class TemplateRequest():
    """Passed between the children of Template"""

    def __init__(self):
        self.pos = Vector((0, 0, 0))
        self.rot = Vector((0, 0, 0))
        self.scale = 1
        self.tags = {}
        self.cm_group = "cm"

        self.materials = {}
        # Key: material to replace. Value: material to replace with

    def copy(self):
        new = TemplateRequest()
        new.pos = self.pos
        new.rot = self.rot
        new.scale = self.scale
        new.tags = self.tags.copy()
        new.cm_group = self.cm_group
        new.materials = self.materials.copy()
        return new

    def toGeoTemplate(self, deferGeo, group):
        new = GeoRequest()
        new.pos = self.pos
        new.rot = self.rot
        new.scale = self.scale
        new.tags = self.tags.copy()
        new.cm_group = self.cm_group
        new.group = group
        new.materials = self.materials.copy()
        new.deferGeo = deferGeo
        return new


class GeoTemplate(Template):
    """Abstract super class.
    GeoTemplates are a description of how to create some arrangement of
     geometry"""

    def build(self, buildRequest):
        """Called when this GeoTemplate is being used to modify the scene"""
        pass


class GeoRequest(TemplateRequest):
    """Passed between the children of GeoTemplate"""

    def __init__(self):
        TemplateRequest.__init__(self)
        self.deferGeo = False
        self.group = None

    def copy(self):
        new = GeoRequest()
        new.pos = self.pos
        new.rot = self.rot
        new.scale = self.scale
        new.tags = self.tags.copy()
        new.cm_group = self.cm_group
        new.group = self.group
        new.materials = self.materials.copy()
        new.deferGeo = self.deferGeo
        return new


class GeoReturn:
    """Object that is passed back by geo template nodes"""

    def __init__(self, obj):
        self.obj = obj
        self.overwriteRig = None
        self.constrainBone = None
        self.modifyBones = {}


# ==================== End of base classes ====================


class GeoTemplateOBJECT(GeoTemplate):
    """For placing objects into the scene"""

    def build(self, buildRequest):
        t = time.time()
        obj = bpy.context.scene.objects[self.settings["inputObject"]]
        if buildRequest.deferGeo:
            cp = bpy.data.objects.new("Empty", None)
            cp.matrix_world = obj.matrix_world
            cp["cm_deferObj"] = obj.name
            cp["cm_materials"] = buildRequest.materials
        else:
            cp = obj.copy()
            for m in cp.material_slots:
                if m.name in buildRequest.materials:
                    replacement = buildRequest.materials[m.name]
                    m.material = bpy.data.materials[replacement]
        buildRequest.group.objects.link(cp)
        bpy.context.scene.objects.link(cp)
        cm_timings.placement["GeoTemplateOBJECT"] += time.time() - t
        cm_timings.placementNum["GeoTemplateOBJECT"] += 1
        return GeoReturn(cp)

    def check(self):
        nobject = self.settings["inputObject"]
        objects = bpy.context.scene.objects
        if (nobject in objects) and (objects[nobject].type == 'MESH'):
            return self.settings["inputObject"] in bpy.context.scene.objects
        logger.debug("The chosen object must exist and be of type MESH.")
        return False


class GeoTemplateGROUP(GeoTemplate):
    """For placing groups into the scene"""

    def build(self, buildRequest):
        t = time.time()
        dat = bpy.data

        pos = buildRequest.pos
        rot = buildRequest.rot
        scale = buildRequest.scale
        group = buildRequest.group
        deferGeo = buildRequest.deferGeo

        gp = [o for o in dat.groups[self.settings["inputGroup"]].objects]
        group_objects = [o.copy() for o in gp]

        def zaxis(x):
            return x.location[2]

        if deferGeo:
            for obj in dat.groups[self.settings["inputGroup"]].objects:
                if obj.type == 'ARMATURE':
                    newObj = obj.copy()
                    newObj.rotation_euler = rot
                    newObj.scale = Vector((scale, scale, scale))
                    newObj.location = pos
                    group.objects.link(newObj)
                    bpy.context.scene.objects.link(newObj)
                    newObj["cm_deferGroup"] = {"group": self.settings["inputGroup"],
                                               "aName": obj.name}
                    newObj["cm_materials"] = buildRequest.materials
                    return GeoReturn(newObj)
            bpy.ops.object.add(type='EMPTY',
                               location=min(group_objects, key=zaxis).location)
            e = bpy.context.object
            group.objects.link(e)
            e["cm_deferGroup"] = {"group": self.settings["inputGroup"]}
            e["cm_materials"] = buildRequest.materials
            cm_timings.placement["GeoTemplateGROUP"] += time.time() - t
            cm_timings.placementNum["GeoTemplateGROUP"] += 1
            return GeoReturn(e)

        topObj = None

        for obj in group_objects:
            for m in obj.material_slots:
                if m.name in buildRequest.materials:
                    replacement = buildRequest.materials[m.name]
                    m.material = bpy.data.materials[replacement]

            if obj.parent in gp:
                obj.parent = group_objects[gp.index(obj.parent)]
            else:
                #obj.rotation_euler = Vector(obj.rotation_euler) + Vector(rot)
                obj.scale = Vector((scale, scale, scale))
                obj.location += pos

            group.objects.link(obj)
            bpy.context.scene.objects.link(obj)
            if obj.type == 'ARMATURE':
                aName = obj.name
                # TODO what if there is more than one armature?
            if obj.type == 'MESH':
                if len(obj.modifiers) > 0:
                    for mod in obj.modifiers:
                        if mod.type == "ARMATURE":
                            modName = mod.name
                            obj.modifiers[modName].object = dat.objects[aName]

            if obj.type == 'ARMATURE':
                topObj = obj

        if topObj is None:  # For if there is no armature object in the group
            bpy.ops.object.add(type='EMPTY',
                               location=min(group_objects, key=zaxis).location)
            e = bpy.context.object
            group.objects.link(e)
            for obj in group_objects:
                if obj.parent not in group_objects:
                    obj.location -= pos
                    obj.parent = e
            topObj = e
        cm_timings.placement["GeoTemplateGROUP"] += time.time() - t
        cm_timings.placementNum["GeoTemplateGROUP"] += 1
        return GeoReturn(topObj)

    def check(self):
        if self.settings["inputGroup"] in bpy.data.groups:
            if len(bpy.data.groups[self.settings["inputGroup"]].objects) != 0:
                return True
        logger.debug("The chosen group must exist and have 1 or more objects.")
        return False


class GeoTemplateLINKGROUPNODE(GeoTemplate):
    def __init__(self, *args):
        GeoTemplate.__init__(self, *args)
        self.linkedGroup = None

    def build(self, buildRequest):
        t = time.time()
        blendfile = os.path.split(bpy.data.filepath)[0]
        for d in self.settings["groupFile"][2:].split("/"):
            if d == "..":
                blendfile = os.path.split(blendfile)[0]
            else:
                blendfile = os.path.join(blendfile, d)

        dupDir = os.path.split(bpy.data.filepath)[0]
        for d in self.settings["duplicatesDirectory"][2:].split("/"):
            if d == "..":
                dupDir = os.path.split(dupDir)[0]
            else:
                dupDir = os.path.join(dupDir, d)

        group = self.settings["groupName"]
        rigObject = self.settings["rigObject"]
        additionalGroup = self.settings["additionalGroup"]

        newObj, newRig = self.duplicateProxyLink(dupDir, blendfile, group, rigObject,
                                                 additionalGroup)
        buildRequest.group.objects.link(newObj)
        buildRequest.group.objects.link(newRig)

        gret = GeoReturn(newObj)

        gret.overwriteRig = newRig
        gret.constrainBone = newRig.pose.bones[self.settings["constrainBone"]]

        cm_timings.placement["GeoTemplateLINKGROUPNODE"] += time.time() - t
        cm_timings.placementNum["GeoTemplateLINKGROUPNODE"] += 1
        return gret

    def check(self):
        # TODO check if file exists
        if self.settings["duplicatesDirectory"] == "":
            logger.debug("The Duplicates Directory must not be empty.")
            return False
        return True

    def duplicateProxyLink(self, dupDir, sourceBlend, sourceGroup, sourceRig,
                           additionalGroup):
        dtGrp = bpy.data.groups
        if not os.path.exists(dupDir):
            os.makedirs(dupDir)

        assetName = sourceGroup.split("-")[0]

        dupliGroup = None

        # Search for unused groups in the current file
        count = 0
        while "{0}.{1:0>3}".format(sourceGroup, count) in dtGrp and dupliGroup is None:
            searchGroup = "{0}.{1:0>3}".format(sourceGroup, count)
            if len(dtGrp[searchGroup].users_dupli_group) == 0:
                dupliGroup = dtGrp[searchGroup]
            else:
                count += 1
        # If no unused group is found then count has the value for what the
        #   group should be.

        # Search for unused duplicate file
        if dupliGroup is None:
            dupFiles = os.listdir(dupDir)
            sourceDir, source = os.path.split(sourceBlend)
            source = source[:-len(".blend")]
            for fileName in dupFiles:
                targetBlendName = "{0}_{1:0>3}.blend".format(source, count)
                if targetBlendName in dupFiles:
                    targetPath = os.path.join(dupDir, targetBlendName)
                    with bpy.data.libraries.load(targetPath, link=True) as (data_src, data_dst):
                        data_dst.groups = [
                            "{0}.{1:0>3}".format(sourceGroup, count)]
                        # if additionalGroup != "":
                        #    data_dst.groups.append(additionalGroup)
                    dupliGroup = data_dst.groups[0]

        # Create a new file
        if dupliGroup is None:
            if self.linkedGroup is None:
                if sourceGroup in bpy.data.groups:
                    if bpy.data.groups[sourceGroup].library is None:
                        self.linkedGroup = bpy.data.groups[sourceGroup]
                    else:
                        # TODO handle this properly
                        raise Exception(
                            "CrowdMaster - Duplicate groups in file")
                else:
                    with bpy.data.libraries.load(sourceBlend, link=False) as (data_src, data_dst):
                        data_dst.groups = [sourceGroup]
                        # if additionalGroup != "":
                        #    data_dst.groups.append(additionalGroup)

                    self.linkedGroup = data_dst.groups[0]

            self.linkedGroup.name = "{0}.{1:0>3}".format(sourceGroup, count)
            newRigName = "{0}.{1:0>3}".format(sourceRig, count)
            self.linkedGroup.objects[sourceRig].name = newRigName

            datablocks = {self.linkedGroup}
            newFileName = "{0}_{1:0>3}.blend".format(source, count)
            newFilePath = os.path.join(dupDir, newFileName)
            bpy.data.libraries.write(newFilePath, datablocks, relative_remap=True,
                                     fake_user=True, compress=False)

            self.linkedGroup.name = sourceGroup
            self.linkedGroup.objects[newRigName].name = sourceRig

            with bpy.data.libraries.load(newFilePath, link=True) as (data_src, data_dst):
                data_dst.groups = ["{0}.{1:0>3}".format(sourceGroup, count)]
                # if additionalGroup != "":
                #    data_dst.groups.append(additionalGroup)
            dupliGroup = data_dst.groups[0]

        # add the group instance to the scene
        scene = bpy.context.scene
        ob = bpy.data.objects.new(
            "cm_{0}.{1:0>3}".format(assetName, count), None)
        ob.dupli_group = dupliGroup
        ob.dupli_type = 'GROUP'
        scene.objects.link(ob)

        activeStore = bpy.context.scene.objects.active
        bpy.context.scene.objects.active = ob

        bpy.ops.object.proxy_make(
            object="{0}.{1:0>3}".format(sourceRig, count))
        rigObj = bpy.context.scene.objects.active

        bpy.context.scene.objects.active = activeStore

        return ob, rigObj


class GeoTemplateCONSTRAINBONE(GeoTemplate):
    def build(self, buildRequest):
        gretp = self.inputs["Parent Group"].build(buildRequest.copy())
        gret = self.inputs["Child Object"].build(buildRequest.copy())

        t = time.time()

        boneName = gret.constrainBone.name

        newRig = gret.overwriteRig
        constrainBone = gret.constrainBone

        lastActive = bpy.context.scene.objects.active
        bpy.context.scene.objects.active = newRig
        bpy.ops.object.posemode_toggle()
        armature = newRig.data.bones
        armature.active = armature[boneName]
        bpy.ops.pose.constraint_add(type="COPY_LOCATION")
        bpy.ops.pose.constraint_add(type="COPY_ROTATION")

        Cloc = newRig.pose.bones[boneName].constraints[-2]
        Crot = newRig.pose.bones[boneName].constraints[-1]

        Cloc.target = gretp.obj
        Cloc.use_z = False

        Crot.target = gretp.obj
        # Crot.use_offset = True

        bpy.ops.object.posemode_toggle()
        bpy.context.scene.objects.active = lastActive

        gretp.overwriteRig = newRig
        gretp.constrainBone = newRig.pose.bones[boneName]

        cm_timings.placement["GeoTemplateCONSTRAINBONE"] += time.time() - t
        cm_timings.placementNum["GeoTemplateCONSTRAINBONE"] += 1
        return gretp

    def check(self):
        if "Parent Group" not in self.inputs:
            logger.debug("There must be a Parent Group input.")
            return False
        if "Child Object" not in self.inputs:
            logger.debug("There must be a Child Object input.")
            return False
        if not isinstance(self.inputs["Parent Group"], GeoTemplate):
            logger.debug("The Parent Group input is not a GeoTemplate type.")
            return False
        if not isinstance(self.inputs["Child Object"], GeoTemplate):
            logger.debug("The Child Object input is not a GeoTemplate type.")
            return False
        # TODO check that object is in parent group
        return True


class GeoTemplateMODIFYBONE(GeoTemplate):
    def build(self, buildRequest):
        gret = self.inputs["Objects"].build(buildRequest)
        t = time.time()
        bn = self.settings["boneName"]
        if bn not in gret.modifyBones:
            gret.modifyBones[bn] = {}
        attrib = self.settings["attribute"]
        gret.modifyBones[bn][attrib] = self.settings["tagName"]

        cm_timings.placement["GeoTemplateMODIFYBONE"] += time.time() - t
        cm_timings.placementNum["GeoTemplateMODIFYBONE"] += 1
        return gret

    def check(self):
        if "Objects" not in self.inputs:
            logger.debug("There must be an Objects input.")
            return False
        if not isinstance(self.inputs["Objects"], GeoTemplate):
            logger.debug("The Objects input is not a GeoTemplate type.")
            return False
        return True


class GeoTemplateSWITCH(GeoTemplate):
    """Randomly (biased by "switchAmout") pick which of the inputs to use"""

    def build(self, buildRequest):
        if random.random() < self.settings["switchAmout"]:
            return self.inputs["Object 1"].build(buildRequest)
        else:
            return self.inputs["Object 2"].build(buildRequest)

    def check(self):
        if "Object 1" not in self.inputs:
            logger.debug("There must be an Object 1 input.")
            return False
        if "Object 2" not in self.inputs:
            logger.debug("There must be an Object 2 input.")
            return False
        if not isinstance(self.inputs["Object 1"], GeoTemplate):
            logger.debug("The Object 1 input is not a GeoTemplate type.")
            return False
        if not isinstance(self.inputs["Object 2"], GeoTemplate):
            logger.debug("The Object 2 input is not a GeoTemplate type.")
            return False
        return True


class GeoTemplatePARENT(GeoTemplate):
    """Attach a piece of geo to a bone from the parent geo"""

    def build(self, buildRequest):
        gretp = self.inputs["Parent Group"].build(buildRequest.copy())
        parent = gretp.obj
        gret = self.inputs["Child Object"].build(buildRequest.copy())
        child = gret.obj

        t = time.time()

        if self.settings["parentMode"] == "bone":
            con = child.constraints.new("CHILD_OF")
            con.target = parent
            try:
                con.subtarget = self.settings["parentTo"]
                bone = parent.pose.bones[self.settings["parentTo"]]
                con.inverse_matrix = bone.matrix.inverted()
                if child.data:
                    child.data.update()
            except:
                logger.info(
                    "The chosed bone was not found in the parent armature!")
        else:
            child.parent = parent
            mod = child.modifiers.get("Armature")
            if mod is None:
                mod = child.modifiers.new("Armature", 'ARMATURE')
            mod.object = parent
            mod.use_vertex_groups = self.settings["bindToVGroups"]
            mod.use_bone_envelopes = self.settings["bindToBEnvelops"]
        cm_timings.placement["GeoTemplatePARENT"] += time.time() - t
        cm_timings.placementNum["GeoTemplatePARENT"] += 1
        return gretp
        # TODO check if the object has an armature modifier

    def check(self):
        if "Parent Group" not in self.inputs:
            logger.debug("There must be a Parent Group input.")
            return False
        if "Child Object" not in self.inputs:
            logger.debug("There must be a Child Object input.")
            return False
        if not isinstance(self.inputs["Parent Group"], GeoTemplate):
            logger.debug("The Parent Group input is not a GeoTemplate type.")
            return False
        if not isinstance(self.inputs["Child Object"], GeoTemplate):
            logger.debug("The Child Object input is not a GeoTemplate type.")
            return False
        # TODO check that object is in parent group
        return True


class TemplateADDTOGROUP(Template):
    """Change the group that agents are added to"""

    def build(self, buildRequest):
        t = time.time()
        scene = bpy.context.scene
        isFrozen = False
        if scene.cm_groups.find(self.settings["groupName"]) != -1:
            group = scene.cm_groups[self.settings["groupName"]]
            isFrozen = group.freezePlacement
            if group.groupType == "auto":
                bpy.ops.scene.cm_groups_reset(
                    groupName=self.settings["groupName"])
            else:
                cm_timings.placement["TemplateADDTOGROUP"] += time.time() - t
                cm_timings.placementNum["TemplateADDTOGROUP"] += 1
                return
        if isFrozen:
            cm_timings.placement["TemplateADDTOGROUP"] += time.time() - t
            cm_timings.placementNum["TemplateADDTOGROUP"] += 1
            return
        newGroup = scene.cm_groups.add()
        newGroup.name = self.settings["groupName"]
        newBuildRequest = buildRequest.copy()
        newBuildRequest.cm_group = self.settings["groupName"]
        cm_timings.placement["TemplateADDTOGROUP"] += time.time() - t
        cm_timings.placementNum["TemplateADDTOGROUP"] += 1
        self.inputs["Template"].build(newBuildRequest)

    def check(self):
        if "Template" not in self.inputs:
            logger.debug("There must be a Template input.")
            return False
        if not isinstance(self.inputs["Template"], Template):
            logger.debug("The Template input is not a Template type.")
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            logger.debug(
                "The Teplate input must be a Template, not GeoTemplate type.")
            return False
        if self.settings["groupName"].strip() == "":
            logger.debug("The Group Name must not be empty.")
            return False
        return True


class TemplateRANDOMMATERIAL(Template):
    """Assign random materials"""

    def build(self, buildRequest):
        t = time.time()
        s = random.random() * self.settings["totalWeight"]
        index = 0
        mat = None
        while mat is None:
            s -= self.settings["materialList"][index][1]
            if s <= 0:
                mat = self.settings["materialList"][index][0]
            index += 1
        buildRequest.materials[self.settings["targetMaterial"]] = mat
        cm_timings.placement["TemplateRANDOMMATERIAL"] += time.time() - t
        cm_timings.placementNum["TemplateRANDOMMATERIAL"] += 1
        self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            logger.debug("There must be a Template input.")
            return False
        if not isinstance(self.inputs["Template"], Template):
            logger.debug("The Template input is not a Template type.")
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            logger.debug(
                "The Teplate input must be a Template, not GeoTemplate type.")
            return False
        return True


class TemplateAGENT(Template):
    """Create a CrowdMaster agent"""

    def build(self, buildRequest):
        t = time.time()
        cm_groups = bpy.context.scene.cm_groups
        gpName = buildRequest.cm_group
        if gpName not in cm_groups or not cm_groups[gpName].freezePlacement:
            groupName = buildRequest.cm_group + \
                "/" + self.settings["brainType"]
            newGp = bpy.data.groups.new(groupName)

            # Put into group by agent group
            if gpName in bpy.data.groups:
                typeGroup = bpy.data.groups[gpName]
            else:
                typeGroup = bpy.data.groups.new(gpName)

            defG = self.settings["deferGeo"]
            pos = buildRequest.pos
            rot = buildRequest.rot
            scale = buildRequest.scale
            geoBuildRequest = buildRequest.toGeoTemplate(defG, newGp)

            t = time.time()
            gret = self.inputs["Objects"].build(geoBuildRequest)
            cm_timings.placement["TemplateAGENT-Build"] += time.time() - t
            cm_timings.placementNum["TemplateAGENT-Build"] += 1
            topObj = gret.obj

            topObj.location = pos
            topObj.rotation_euler = rot
            topObj.scale = Vector((scale, scale, scale))

            topObj["cm_randomMaterial"] = buildRequest.materials

            tags = buildRequest.tags
            packTags = [{"name": x, "value": tags[x]} for x in tags]

            rigOverwrite = gret.overwriteRig.name if gret.overwriteRig else ""
            constrainBone = gret.constrainBone.name if gret.constrainBone else ""

            packModifyBones = []
            for b in gret.modifyBones:
                for attribute in gret.modifyBones[b]:
                    tag = gret.modifyBones[b][attribute]
                    packModifyBones.append({"name": b,
                                            "attribute": attribute,
                                            "tag": tag})

            t = time.time()
            SCENE_OT_cm_agent_add._execute(bpy.context,
                                           topObj.name,
                                           self.settings["brainType"],
                                           buildRequest.cm_group,
                                           newGp.name,
                                           packTags,
                                           rigOverwrite,
                                           constrainBone,
                                           packModifyBones)
            cm_timings.placement["TemplateAGENT-cm_agent_add"] += time.time() - t
            cm_timings.placementNum["TemplateAGENT-cm_agent_add"] += 1

        cm_timings.placement["TemplateAGENT"] += time.time() - t
        cm_timings.placementNum["TemplateAGENT"] += 1

    def check(self):
        if "Objects" not in self.inputs:
            logger.debug("There must be an Objects input.")
            return False
        if not isinstance(self.inputs["Objects"], GeoTemplate):
            logger.debug("The Objects input is not a GeoTemplate type.")
            return False
        return True


class TemplateSWITCH(Template):
    """Randomly (biased by "switchAmout") pick which of the inputs to use"""

    def build(self, buildRequest):
        if random.random() < self.settings["switchAmout"]:
            self.inputs["Template 1"].build(buildRequest)
        else:
            self.inputs["Template 2"].build(buildRequest)

    def check(self):
        if "Template 1" not in self.inputs:
            logger.debug("There must be a Template 2 input.")
            return False
        if "Template 2" not in self.inputs:
            logger.debug("There must be a Template 2 input.")
            return False
        if not isinstance(self.inputs["Template 1"], Template):
            logger.debug("The Template 1 input is not a Template type.")
            return False
        if isinstance(self.inputs["Template 1"], GeoTemplate):
            logger.debug(
                "The Teplate 1 input must be a Template, not GeoTemplate type.")
            return False
        if not isinstance(self.inputs["Template 2"], Template):
            logger.debug("The Template 2 input is not a Template type.")
            return False
        if isinstance(self.inputs["Template 2"], GeoTemplate):
            logger.debug(
                "The Teplate 2 input must be a Template, not GeoTemplate type.")
            return False
        return True


class TemplateOFFSET(Template):
    """Modify the postion and/or the rotation of the request made"""

    def build(self, buildRequest):
        t = time.time()
        nPos = Vector()
        nRot = Vector()
        if not self.settings["overwrite"]:
            nPos = Vector(buildRequest.pos)
            nRot = Vector(buildRequest.rot)
        if self.settings["referenceObject"] != "":
            refObj = bpy.data.objects[self.settings["referenceObject"]]
            nPos += refObj.location
            nRot += Vector(refObj.rotation_euler)
        nPos += self.settings["locationOffset"]
        tmpRot = self.settings["rotationOffset"]
        nRot += Vector((radians(tmpRot.x),
                        radians(tmpRot.y), radians(tmpRot.z)))
        buildRequest.pos = nPos
        buildRequest.rot = nRot

        cm_timings.placement["TemplateOFFSET"] += time.time() - t
        cm_timings.placementNum["TemplateOFFSET"] += 1

        self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            logger.debug("There must be a Template input.")
            return False
        if not isinstance(self.inputs["Template"], Template):
            logger.debug("The Template input is not a Template type.")
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            logger.debug("The Teplate input must be a Template, not GeoTemplate type.")
            return False
        ref = self.settings["referenceObject"]
        if ref != "" and ref not in bpy.context.scene.objects:
            logger.debug("The Reference object must exist.")
            return False
        return True


class TemplateRANDOM(Template):
    """Randomly modify rotation and scale of the request made"""

    def build(self, buildRequest):
        t = time.time()
        rotDiff = random.uniform(self.settings["minRandRot"],
                                 self.settings["maxRandRot"])
        eul = mathutils.Euler(buildRequest.rot, 'XYZ')
        eul.rotate_axis('Z', math.radians(rotDiff))

        scaleDiff = random.uniform(self.settings["minRandSz"],
                                   self.settings["maxRandSz"])
        newScale = buildRequest.scale * scaleDiff

        buildRequest.rot = Vector(eul)
        buildRequest.scale = newScale
        cm_timings.placement["TemplateRANDOM"] += time.time() - t
        cm_timings.placementNum["TemplateRANDOM"] += 1
        self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplatePOINTTOWARDS(Template):
    """Rotate to point towards object or closest point on mesh"""

    def __init__(self, inputs, settings, bpyName):
        Template.__init__(self, inputs, settings, bpyName)
        self.kdtree = None

    def build(self, buildRequest):
        t = time.time()
        ob = bpy.context.scene.objects[self.settings["PointObject"]]
        pos = buildRequest.pos
        if self.settings["PointType"] == "OBJECT":
            point = ob.location
        else:  # self.settings["PointObject"] == "MESH":
            if self.kdtree is None:
                mesh = ob.data
                self.kdtree = KDTree(len(mesh.vertices))
                for i, v in enumerate(mesh.vertices):
                    self.kdtree.insert(v.co, i)
                self.kdtree.balance()
            co, ind, dist = self.kdtree.find(ob.matrix_world.inverted() * pos)
            point = ob.matrix_world * co
        direc = point - pos
        rotQuat = direc.to_track_quat('Y', 'Z')
        buildRequest.rot = rotQuat.to_euler()
        cm_timings.placement["TemplatePOINTTOWARDS"] += time.time() - t
        cm_timings.placementNum["TemplatePOINTTOWARDS"] += 1
        self.inputs["Template"].build(buildRequest)

    def check(self):
        if self.settings["PointObject"] not in bpy.context.scene.objects:
            return False
        if self.settings["PointType"] == "MESH":
            if bpy.context.scene.objects[self.settings["PointObject"]].type != 'MESH':
                return False
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplateCOMBINE(Template):
    """Duplicate request to all inputs"""

    def build(self, buildRequest):
        for name, inp in self.inputs.items():
            newBuildRequest = buildRequest.copy()
            inp.build(newBuildRequest)


class TemplateRANDOMPOSITIONING(Template):
    """Place randomly"""

    def build(self, buildRequest):
        t = time.time()
        positions = []
        for a in range(self.settings["noToPlace"]):
            if self.settings["locationType"] == "radius":
                angle = random.uniform(-math.pi, math.pi)
                x = math.sin(angle)
                y = math.cos(angle)
                length = random.random() + random.random()
                if length > 1:
                    length = 2 - length
                length *= self.settings["radius"]
                x *= length
                y *= length
                diff = Vector((x, y, 0))
                diff.rotate(mathutils.Euler(buildRequest.rot))
                newPos = Vector(buildRequest.pos) + diff
                positions.append(newPos)
            elif self.settings["locationType"] == "area":
                MaxX = self.settings["MaxX"] / 2
                MaxY = self.settings["MaxY"] / 2
                x = random.uniform(-MaxX, MaxX)
                y = random.uniform(-MaxY, MaxY)
                diff = Vector((x, y, 0))
                newPos = Vector(buildRequest.pos) + diff
                positions.append(newPos)
            elif self.settings["locationType"] == "sector":
                direc = self.settings["direc"]
                angVar = self.settings["angle"] / 2
                angle = random.uniform(-angVar, angVar)
                x = math.sin(math.radians(angle + direc))
                y = math.cos(math.radians(angle + direc))
                length = random.random() + random.random()
                if length > 1:
                    length = 2 - length
                length *= self.settings["radius"]
                x *= length
                y *= length
                diff = Vector((x, y, 0))
                diff.rotate(mathutils.Euler(buildRequest.rot))
                newPos = Vector(buildRequest.pos) + diff
                positions.append(newPos)
        if self.settings["relax"]:
            radius = self.settings["relaxRadius"]
            for i in range(self.settings["relaxIterations"]):
                kd = KDTree(len(positions))
                for n, p in enumerate(positions):
                    kd.insert(p, n)
                kd.balance()
                for n, p in enumerate(positions):
                    adjust = Vector()
                    localPoints = kd.find_range(p, radius * 2)
                    for (co, ind, dist) in localPoints:
                        if ind != n:
                            v = p - co
                            if v.length > 0:
                                adjust += v * \
                                    ((2 * radius - v.length) / v.length)
                    if len(localPoints) > 0:
                        positions[n] += adjust / len(localPoints)
        cm_timings.placement["TemplateRANDOMPOSITIONING"] += time.time() - t
        cm_timings.placementNum["TemplateRANDOMPOSITIONING"] += 1
        for newPos in positions:
            newBuildRequest = buildRequest.copy()
            newBuildRequest.pos = newPos
            self.inputs["Template"].build(newBuildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplateMESHPOSITIONING(Template):
    """Place randomly over the surface of a mesh"""

    def __init__(self, inputs, settings, bpyName):
        Template.__init__(self, inputs, settings, bpyName)
        self.bvhtree = None
        self.totalArea = None

    def build(self, buildRequest):
        t = time.time()
        guide = bpy.data.objects[self.settings["guideMesh"]]
        data = guide.data

        wrld = guide.matrix_world
        if self.totalArea is None:
            self.totalArea = sum(p.area for p in data.polygons)
        positions = []
        for n in range(self.settings["noToPlace"]):
            remaining = random.random() * self.totalArea
            index = 0
            while remaining > 0:
                remaining -= data.polygons[index].area
                if remaining <= 0:
                    a = data.vertices[data.polygons[index].vertices[0]].co
                    b = data.vertices[data.polygons[index].vertices[1]].co
                    c = data.vertices[data.polygons[index].vertices[2]].co
                    r1 = math.sqrt(random.random())
                    r2 = random.random()
                    pos = (1 - r1) * a + (r1 * (1 - r2)) * b + (r1 * r2) * c
                    if self.settings["overwritePosition"]:
                        pos = wrld * pos
                    else:
                        pos.rotate(mathutils.Euler(buildRequest.rot))
                        pos *= buildRequest.scale
                        pos = buildRequest.pos + pos
                    positions.append(pos)
                index += 1

        if self.settings["relax"]:
            sce = bpy.context.scene
            gnd = sce.objects[self.settings["guideMesh"]]
            if self.bvhtree is None:
                self.bvhtree = BVHTree.FromObject(gnd, sce)
            radius = self.settings["relaxRadius"]
            for i in range(self.settings["relaxIterations"]):
                kd = KDTree(len(positions))
                for n, p in enumerate(positions):
                    kd.insert(p, n)
                kd.balance()
                for n, p in enumerate(positions):
                    adjust = Vector()
                    localPoints = kd.find_range(p, radius * 2)
                    for (co, ind, dist) in localPoints:
                        if ind != n:
                            v = p - co
                            if v.length > 0:
                                adjust += v * \
                                    ((2 * radius - v.length) / v.length)
                    if len(localPoints) > 0:
                        adjPos = positions[n] + adjust / len(localPoints)
                        positions[n] = self.bvhtree.find_nearest(adjPos)[0]

        cm_timings.placement["TemplateMESHPOSITIONING"] += time.time() - t
        cm_timings.placementNum["TemplateMESHPOSITIONING"] += 1

        for newPos in positions:
            newBuildRequest = buildRequest.copy()
            newBuildRequest.pos = newPos
            self.inputs["Template"].build(newBuildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if self.settings["guideMesh"] not in bpy.context.scene.objects:
            return False
        if bpy.context.scene.objects[self.settings["guideMesh"]].type != 'MESH':
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplateVCOLPOSITIONING(Template):
    """Place randomly over the surface of a mesh"""

    def __init__(self, inputs, settings, bpyName):
        Template.__init__(self, inputs, settings, bpyName)
        self.bvhtree = None
        self.totalArea = None

    def build(self, buildRequest):
        t = time.time()
        paintMode = self.settings["paintMode"]
        guide = bpy.data.objects[self.settings["guideMesh"]]
        invert = self.settings["invert"]
        data = guide.data
        polys = []

        vcol_layer = data.vertex_colors[self.settings["vcols"]]

        for poly in data.polygons:
            for loop_index in poly.loop_indices:
                loop_vert_index = data.loops[loop_index].vertex_index
                diff = vcol_layer.data[loop_index].color - self.settings["vcolor"]
                if not invert:
                    if abs(diff.r) < 0.01 and abs(diff.g) < 0.01 and abs(diff.b) < 0.01:
                        polys.append(poly)
                else:
                    if not (abs(diff.r) < 0.01 and abs(diff.g) < 0.01 and abs(diff.b) < 0.01):
                        polys.append(poly)

        wrld = guide.matrix_world
        if self.totalArea is None:
            self.totalArea = sum(p.area for p in polys)

        if paintMode == 'place':
            positions = []
            for n in range(self.settings["noToPlace"]):
                remaining = random.random() * self.totalArea
                index = 0
                while remaining > 0:
                    remaining -= polys[index].area
                    if remaining <= 0:
                        a = data.vertices[polys[index].vertices[0]].co
                        b = data.vertices[polys[index].vertices[1]].co
                        c = data.vertices[polys[index].vertices[2]].co
                        r1 = math.sqrt(random.random())
                        r2 = random.random()
                        pos = (1 - r1) * a + (r1 * (1 - r2)) * \
                            b + (r1 * r2) * c
                        if self.settings["overwritePosition"]:
                            pos = wrld * pos
                        else:
                            pos.rotate(mathutils.Euler(buildRequest.rot))
                            pos *= buildRequest.scale
                            pos = buildRequest.pos + pos
                        positions.append(pos)
                    index += 1

            if self.settings["relax"]:
                sce = bpy.context.scene
                gnd = sce.objects[self.settings["guideMesh"]]
                if self.bvhtree is None:
                    self.bvhtree = BVHTree.FromObject(gnd, sce)
                radius = self.settings["relaxRadius"]
                for n, p in enumerate(positions):
                    rvec = random.random() * mathutils.noise.random_unit_vector()
                    positions[n] = p + rvec * radius
                for i in range(self.settings["relaxIterations"]):
                    kd = KDTree(len(positions))
                    for n, p in enumerate(positions):
                        kd.insert(p, n)
                    kd.balance()
                    for n, p in enumerate(positions):
                        adjust = Vector()
                        localPoints = kd.find_range(p, radius * 2)
                        for (co, ind, dist) in localPoints:
                            if ind != n:
                                v = p - co
                                if v.length > 0:
                                    adjust += v * \
                                        ((2 * radius - v.length) / v.length)
                        if len(localPoints) > 0:
                            adjPos = positions[n] + adjust / len(localPoints)
                            positions[n] = self.bvhtree.find_nearest(adjPos)[0]

            cm_timings.placement["TemplateVCOLPOSITIONING"] += time.time() - t
            cm_timings.placementNum["TemplateVCOLPOSITIONING"] += 1

            for newPos in positions:
                newBuildRequest = buildRequest.copy()
                newBuildRequest.pos = newPos
                self.inputs["Template"].build(newBuildRequest)

        elif paintMode == 'edit':
            sce = bpy.context.scene
            gnd = sce.objects[self.settings["guideMesh"]]
            if self.bvhtree is None:
                self.bvhtree = BVHTree.FromObject(gnd, sce)

            point = buildRequest.pos
            loc, norm, ind, dist = self.bvhtree.find_nearest(point)
            poly = data.polygons[ind]

            cm_timings.placement["TemplateVCOLPOSITIONING"] += time.time() - t
            cm_timings.placementNum["TemplateVCOLPOSITIONING"] += 1

            for loop_index in poly.loop_indices:
                loop_vert_index = data.loops[loop_index].vertex_index
                if not invert:
                    if vcol_layer.data[loop_index].color == self.settings["vcolor"]:
                        self.inputs["Template"].build(buildRequest)
                else:
                    if not vcol_layer.data[loop_index].color == self.settings["vcolor"]:
                        self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if self.settings["guideMesh"] not in bpy.context.scene.objects:
            return False
        if self.settings["vcols"] == "":
            return False
        if bpy.context.scene.objects[self.settings["guideMesh"]].type != 'MESH':
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


def assignConnectedToIsland(vert, islandID, islandNo):
    if vert[islandID] == 0:
        vert[islandID] = islandNo
        for edge in vert.link_edges:
            assignConnectedToIsland(edge.other_vert(vert), islandID, islandNo)


class TemplatePATH(Template):
    """Place along a path"""

    def build(self, buildRequest):
        t = time.time()

        pathEntry = bpy.context.scene.cm_paths.coll.get(
            self.settings["pathName"])
        obj = bpy.context.scene.objects[pathEntry.objectName]
        bm = bmesh.new()
        bm.from_mesh(obj.data)

        if self.settings["groupByMeshIsland"]:
            bm.verts.ensure_lookup_table()
            islandID = bm.verts.layers.int.new('island')
            islandNo = 1
            for vert in bm.verts:
                if vert[islandID] == 0:
                    assignConnectedToIsland(vert, islandID, islandNo)
                    islandNo += 1

        bm.edges.ensure_lookup_table()

        totalEdge = 0
        edgeWeights = []
        for e in bm.edges:
            length = e.calc_length()
            totalEdge += length
            edgeWeights.append(length)

        positions = []

        for n in range(self.settings["noToPlace"]):
            rem = random.random() * totalEdge
            ind = -1
            while rem > 0:
                ind += 1
                rem -= edgeWeights[ind]
            weight = random.random()
            vs = bm.edges[ind].verts
            localPos = vs[0].co * weight + vs[1].co * (1 - weight)
            pos = localPos * obj.matrix_world
            # TODO look at path object and get rotation to align with path direction
            globalPos, pointTowards, cid = tmpPathChannel.alignToPath(pathEntry, pos,
                                                                      Vector((1, 0, 0)))
            diff = pointTowards - globalPos
            rot = diff.to_track_quat('Y', 'Z').to_euler()

            if self.settings["groupByMeshIsland"]:
                island = bm.verts[cid][islandID]
            else:
                island = 0

            positions.append((pos, rot, island))

        if self.settings["relax"]:
            sce = bpy.context.scene
            radius = self.settings["relaxRadius"]
            for i in range(self.settings["relaxIterations"]):
                kd = KDTree(len(positions))
                for n, (p, r, island) in enumerate(positions):
                    kd.insert(p, n)
                kd.balance()
                for n, (p, r, island) in enumerate(positions):
                    adjust = Vector()
                    localPoints = kd.find_range(p, radius * 2)
                    for (co, ind, dist) in localPoints:
                        if ind != n:
                            v = p - co
                            if v.length > 0:
                                adjust += v * \
                                    ((2 * radius - v.length) / v.length)
                    if len(localPoints) > 0:
                        adjPos = p + adjust / len(localPoints)
                        normal = Vector((0, 1, 0))
                        normal.rotate(Euler(r))
                        pos, pointTowards, cid = tmpPathChannel.alignToPath(pathEntry,
                                                                            adjPos,
                                                                            normal)
                        diff = pointTowards - pos
                        rot = diff.to_track_quat('Y', 'Z').to_euler()
                        if self.settings["groupByMeshIsland"]:
                            island = bm.verts[cid][islandID]
                        else:
                            island = 0
                        positions[n] = (pos, rot, island)

        cm_timings.placement["TemplatePATH"] += time.time() - t
        cm_timings.placementNum["TemplatePATH"] += 1

        for newPos, newRot, island in positions:
            newBuildRequest = buildRequest.copy()
            newBuildRequest.pos = newPos + buildRequest.pos
            newBuildRequest.rot = newRot  # + buildRequest.rot
            if self.settings["groupByMeshIsland"]:
                newBuildRequest.cm_group += "_" + self.settings["nodeName"] + \
                                            "_" + str(island)
            self.inputs["Template"].build(newBuildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        pathEntry = bpy.context.scene.cm_paths.coll.get(
            self.settings["pathName"])
        obj = bpy.context.scene.objects[pathEntry.objectName]
        if not obj.type == 'MESH':
            return False


class TemplateFORMATION(Template):
    """Place in a row"""

    def build(self, buildRequest):
        t = time.time()

        placePos = Vector(buildRequest.pos)
        diffRow = Vector((self.settings["ArrayRowMargin"], 0, 0))
        diffCol = Vector((0, self.settings["ArrayColumnMargin"], 0))
        diffRow.rotate(mathutils.Euler(buildRequest.rot))
        diffCol.rotate(mathutils.Euler(buildRequest.rot))
        diffRow *= buildRequest.scale
        diffCol *= buildRequest.scale
        number = self.settings["noToPlace"]
        rows = self.settings["ArrayRows"]

        cm_timings.placement["TemplateFORMATION"] += time.time() - t
        cm_timings.placementNum["TemplateFORMATION"] += 1

        for fullcols in range(number // rows):
            for row in range(rows):
                newBuildRequest = buildRequest.copy()
                newBuildRequest.pos = placePos + fullcols * diffCol + row * diffRow
                self.inputs["Template"].build(newBuildRequest)

        for leftOver in range(number % rows):
            newBuild = buildRequest.copy()
            newBuild.pos = placePos + \
                (number // rows) * diffCol + leftOver * diffRow
            self.inputs["Template"].build(newBuild)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplateTARGET(Template):
    """Place based on the positions of vertices"""

    def build(self, buildRequest):
        t = time.time()
        if self.settings["targetType"] == "object":
            objs = bpy.data.groups[self.settings["targetGroups"]].objects
            if self.settings["overwritePosition"]:
                for obj in objs:
                    newBuildRequest = buildRequest.copy()
                    newBuildRequest.pos = obj.location
                    newBuildRequest.rot = Vector(obj.rotation_euler)

                    cm_timings.placement[
                        "TemplateTARGET"] += time.time() - t

                    self.inputs["Template"].build(newBuildRequest)

                    t = time.time()
            else:
                for obj in objs:
                    loc = obj.location
                    oRot = Vector(obj.rotation_euler)
                    loc.rotate(mathutils.Euler(buildRequest.rot))
                    loc *= buildRequest.scale
                    newBuildRequest = buildRequest.copy()
                    newBuildRequest.pos = loc + buildRequest.pos
                    newBuildRequest.rot = buildRequest.rot + oRot

                    cm_timings.placement[
                        "TemplateTARGET"] += time.time() - t

                    self.inputs["Template"].build(newBuildRequest)

                    t = time.time()
        else:  # targetType == "vertex"
            obj = bpy.data.objects[self.settings["targetObject"]]
            if self.settings["overwritePosition"]:
                wrld = obj.matrix_world
                targets = [wrld * v.co for v in obj.data.vertices]
                newRot = Vector(obj.rotation_euler)
                for vert in targets:
                    newBuildRequest = buildRequest.copy()
                    newBuildRequest.pos = vert
                    newBuildRequest.rot = newRot

                    cm_timings.placement[
                        "TemplateTARGET"] += time.time() - t

                    self.inputs["Template"].build(newBuildRequest)

                    t = time.time()
            else:
                targets = [Vector(v.co) for v in obj.data.vertices]
                for loc in targets:
                    loc.rotate(mathutils.Euler(buildRequest.rot))
                    loc *= buildRequest.scale
                    newBuildRequest = buildRequest.copy()
                    newBuildRequest.pos = loc + buildRequest.pos

                    cm_timings.placement[
                        "TemplateTARGET"] += time.time() - t

                    self.inputs["Template"].build(newBuildRequest)

                    t = time.time()
        cm_timings.placementNum["TemplateTARGET"] += 1

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        if self.settings["targetType"] == "object":
            if self.settings["targetGroups"] not in bpy.data.groups:
                return False
        elif self.settings["targetType"] == "vertex":
            if self.settings["targetObject"] not in bpy.context.scene.objects:
                return False
            if bpy.context.scene.objects[self.settings["targetObject"]].type != 'MESH':
                return False
        return True


class TemplateOBSTACLE(Template):
    """Refuse any requests that are withing the bounding box of an obstacle"""

    def __init__(self, inputs, settings, bpyName):
        Template.__init__(self, inputs, settings, bpyName)
        self.octree = None

    def build(self, buildRequest):
        t = time.time()
        if self.octree is None:
            objs = bpy.data.groups[self.settings["obstacleGroup"]].objects
            margin = self.settings["margin"]
            mVec = Vector((margin, margin, margin))
            radii = [(o.dimensions / 2) + mVec for o in objs]
            self.octree = createOctreeFromBPYObjs(objs, allSpheres=False,
                                                  radii=radii)
        intersections = self.octree.checkPoint(buildRequest.pos)

        cm_timings.placement["TemplateOBSTACLE"] += time.time() - t
        cm_timings.placementNum["TemplateOBSTACLE"] += 1

        if len(intersections) == 0:
            self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        if self.settings["obstacleGroup"] not in bpy.data.groups:
            return False
        return True


class TemplateGROUND(Template):
    """Adjust the position of requests onto a ground mesh"""

    def __init__(self, inputs, settings, bpyName):
        Template.__init__(self, inputs, settings, bpyName)
        self.bvhtree = None

    def build(self, buildRequest):
        t = time.time()
        sce = bpy.context.scene
        gnd = sce.objects[self.settings["groundMesh"]]
        if self.bvhtree is None:
            self.bvhtree = BVHTree.FromObject(gnd, sce)

        inverseTransform = gnd.matrix_world.inverted()
        point = (inverseTransform * buildRequest.pos.to_4d()).to_3d()
        direc = Vector((0, 0, 1))
        direc.rotate(inverseTransform.to_euler())

        hitA, normA, indA, distA = self.bvhtree.ray_cast(point,
                                                         tuple(-x for x in direc))
        if hitA is not None:
            hitA = gnd.matrix_world * hitA
            normA = gnd.matrix_world * normA
            distA = (buildRequest.pos - hitA).length

        hitB, normB, indB, distB = self.bvhtree.ray_cast(point,
                                                         tuple(x for x in direc))
        if hitB is not None:
            hitB = gnd.matrix_world * hitB
            normB = gnd.matrix_world * normB
            distB = (buildRequest.pos - hitB).length

        cm_timings.placement["TemplateGROUND"] += time.time() - t
        cm_timings.placementNum["TemplateGROUND"] += 1

        if hitA and hitB:
            if distA <= distB:
                buildRequest.pos = hitA
                self.inputs["Template"].build(buildRequest)
            else:
                buildRequest.pos = hitB
                self.inputs["Template"].build(buildRequest)
        elif hitA:
            buildRequest.pos = hitA
            self.inputs["Template"].build(buildRequest)
        elif hitB:
            buildRequest.pos = hitB
            self.inputs["Template"].build(buildRequest)

    def check(self):
        if self.settings["groundMesh"] not in bpy.context.scene.objects:
            return False
        if bpy.context.scene.objects[self.settings["groundMesh"]].type != 'MESH':
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


class TemplateSETTAG(Template):
    """Set a tag for an agent to start with"""

    def build(self, buildRequest):
        buildRequest.tags[self.settings["tagName"]] = self.settings["tagValue"]
        self.inputs["Template"].build(buildRequest)

    def check(self):
        if "Template" not in self.inputs:
            return False
        if not isinstance(self.inputs["Template"], Template):
            return False
        if isinstance(self.inputs["Template"], GeoTemplate):
            return False
        return True


templates = OrderedDict([
    ("ObjectInputNodeType", GeoTemplateOBJECT),
    ("GroupInputNodeType", GeoTemplateGROUP),
    ("LinkGroupNodeType", GeoTemplateLINKGROUPNODE),
    ("ConstrainNodeType", GeoTemplateCONSTRAINBONE),
    ("ModifyBoneNodeType", GeoTemplateMODIFYBONE),
    ("GeoSwitchNodeType", GeoTemplateSWITCH),
    ("AddToGroupNodeType", TemplateADDTOGROUP),
    ("TemplateSwitchNodeType", TemplateSWITCH),
    ("ParentNodeType", GeoTemplatePARENT),
    ("RandomMaterialNodeType", TemplateRANDOMMATERIAL),
    ("TemplateNodeType", TemplateAGENT),
    ("OffsetNodeType", TemplateOFFSET),
    ("RandomNodeType", TemplateRANDOM),
    ("PointTowardsNodeType", TemplatePOINTTOWARDS),
    ("CombineNodeType", TemplateCOMBINE),
    ("RandomPositionNodeType", TemplateRANDOMPOSITIONING),
    ("MeshPositionNodeType", TemplateMESHPOSITIONING),
    ("VCOLPositionNodeType", TemplateVCOLPOSITIONING),
    ("PathPositionNodeType", TemplatePATH),
    ("FormationPositionNodeType", TemplateFORMATION),
    ("TargetPositionNodeType", TemplateTARGET),
    ("ObstacleNodeType", TemplateOBSTACLE),
    ("GroundNodeType", TemplateGROUND),
    ("SettagNodeType", TemplateSETTAG)
])
